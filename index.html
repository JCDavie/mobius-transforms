<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script>

function p2( x, y ) { return { x:x, y:y }; }
function add( a, b ) { return p2( a.x + b.x, a.y + b.y ); }
function sub( a, b ) { return p2( a.x - b.x, a.y - b.y ); }
function mul( a, f ) { return p2( a.x * f, a.y * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y; }
function len2( a ) { return dot(a,a); }
function dist2( a, b ) { return len2( sub( a, b ) ); }
function dist( a, b ) { return Math.sqrt( dist2( a, b ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; }
function normalize( a ) { return mul( a, 1 / Math.sqrt( len2( a ) ) ); }
function mul_complex( a, b ) { return p2( a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y ); }
function div_complex( a, b ) { return p2( ( a.x * b.x + a.y * b.y ) / len2( b ), ( a.y * b.x - a.x * b.y ) / len2( b ) ); }
function mobius( z, a, b, c, d ) { return div_complex( add( mul_complex( a, z ), b ), add( mul_complex( c, z ), d ) ); }
function flip_y( p ) { return p2( p.x, -p.y ); }

function toScreen( p ) { return add( origin_screen, flip_y( mul( p, scale ) ) ); }
function fromScreen( p ) { return mul( flip_y( sub( p, origin_screen ) ), 1.0 / scale ); }

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        control_points[ i_point ] = fromScreen( pos );
        draw();
    }
    else {
        // find the closest point, if within an minimum radius
        var iClosest = -1;
        var closest_dist2 = 10 * 10;
        for( var i = 0; i < 4; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                cloest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            draw();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            draw();
        }    
    }
}

function onTouchMove( evt ) {
    evt.preventDefault();
    onMove( p2( evt.changedTouches[0].clientX, evt.changedTouches[0].clientY ) );
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    evt.preventDefault();
    onDown( p2( evt.changedTouches[0].clientX, evt.changedTouches[0].clientY ) );
}

function onDown( pos ) {    
    // find the closest point, if within an minimum radius
    var iClosest = -1;
    var closest_dist2 = 10 * 10;
    for( var i = 0; i < 4; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            cloest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        draw();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        draw();
    }    
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        draw();
    }    
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        draw();
    }
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    
    control_points = [ p2( 1.0, 0.0 ), p2( 0.2, 0.1 ), p2( 0.3, 0.4 ), p2( 1.1, -0.1 ) ];
    
    origin_screen = p2( canvas.width/2, canvas.height/2 );
    scale = Math.min( canvas.width, canvas.height ) / 2;
    
    point_is_highlighted = false;
    point_is_being_dragged = false;
    i_point = -1;
    
    draw();
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

function point( p, r, t, t_offset ) { 
    ctx.beginPath(); 
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI ); 
    ctx.fillText( t, p.x + 3 + t_offset.x, p.y - 3 + t_offset.y );
    ctx.fill(); 
}

// adapted from http://stackoverflow.com/a/6333775/126823
function canvas_arrow( context, fromx, fromy, tox, toy ) { 
    var headlen = 5; // length of head in pixels
    var end_gap = 0; // distance of head and tail from requested positions
    var angle = Math.atan2(toy-fromy,tox-fromx);
    fromx += end_gap * Math.cos(angle);
    fromy += end_gap * Math.sin(angle);
    tox -= end_gap * Math.cos(angle);
    toy -= end_gap * Math.sin(angle);
    context.moveTo(fromx, fromy);
    context.lineTo(tox, toy);
    context.moveTo(tox-headlen*Math.cos(angle-Math.PI/6),toy-headlen*Math.sin(angle-Math.PI/6));
    context.lineTo(tox, toy);
    context.lineTo(tox-headlen*Math.cos(angle+Math.PI/6),toy-headlen*Math.sin(angle+Math.PI/6));
}

function draw() {

    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // draw the axes
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    sp1 = toScreen( p2( -100, 0 ) );
    sp2 = toScreen( p2( 100, 0 ) );
    ctx.moveTo( sp1.x, sp1.y );
    ctx.lineTo( sp2.x, sp2.y );
    sp1 = toScreen( p2( 0, -100 ) );
    sp2 = toScreen( p2( 0, 100 ) );
    ctx.moveTo( sp1.x, sp1.y );
    ctx.lineTo( sp2.x, sp2.y );
    ctx.stroke();
    
    // draw arrows showing the transform
    ctx.strokeStyle = "rgba(0,0,0,0.4)";
    var spacing = 40;
    var sample_rect = { x:0, y:0, width:canvas.width, height:canvas.height };
    var canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };
    ctx.beginPath();
    for( var x = sample_rect.x + spacing / 2; x < sample_rect.x + sample_rect.width; x += spacing ) {
        for( var y = sample_rect.y + spacing / 2; y < sample_rect.y + sample_rect.height; y += spacing ) {
            sp = p2( x, y );
            p = fromScreen( sp );
            q = mobius( p, control_points[0], control_points[1], control_points[2], control_points[3] );
            sq = toScreen( q );
            if( pointInRect( sp, canvas_rect ) || pointInRect( sq, canvas_rect ) )
                canvas_arrow( ctx, sp.x, sp.y, sq.x, sq.y );
        }
    }
    ctx.stroke();
    
    // draw the four control points
    ctx.font="18px Arial";
    var rest_color = "rgb(0,0,0)";
    var highlighted_color = "rgb(0,255,255)";
    var dragging_color = "rgb(0,255,0)";
    for( var i = 0; i < 4; i++ ) {
        if( point_is_highlighted && i_point == i )
            ctx.fillStyle = ctx.strokeStyle = highlighted_color;
        else if( point_is_being_dragged && i_point == i )
            ctx.fillStyle = ctx.strokeStyle = dragging_color;
        else
            ctx.fillStyle = ctx.strokeStyle = rest_color;
        point( toScreen( control_points[ i ] ), 4, "abcd"[i], p2(0,0) );
    }
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<p align="center"><canvas id="canvas" width="1500" height="600">(Canvas drawing not supported by your browser.)</canvas></p>

<p>The <b><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">Möbius transformation</a></b> is <b>f( z ) = ( az + b ) / ( cz + d )</b> where <b>z</b>, <b>a</b>,
<b>b</b>, <b>c</b> and <b>d</b> are complex numbers.</p>

<p>Drag the points to change the transformation.</p>

</html>
