<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script>

function p2( x, y ) { return { x:x, y:y }; }
function add( a, b ) { return p2( a.x + b.x, a.y + b.y ); }
function sub( a, b ) { return p2( a.x - b.x, a.y - b.y ); }
function mul( a, f ) { return p2( a.x * f, a.y * f ); }
function average( a, b ) { return mul( add( a, b ), 0.5 ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y; }
function len2( a ) { return dot(a,a); }
function dist2( a, b ) { return len2( sub( a, b ) ); }
function dist( a, b ) { return Math.sqrt( len2( sub( a, b ) ) ); }
function mul_complex( a, b ) { return p2( a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y ); }
function div_complex( a, b ) { return p2( ( a.x * b.x + a.y * b.y ) / len2( b ), ( a.y * b.x - a.x * b.y ) / len2( b ) ); }
function magnitude( a ) { return Math.sqrt( len2( a ) ); }
function phase( a ) { return Math.atan2( a.y, a.x ); }
function fromPolar( mag, phase ) { return p2( mag * Math.cos(phase), mag*Math.sin(phase) ) }
function sqrt_complex( a ) { return fromPolar( Math.sqrt( magnitude(a) ), phase(a) / 2.0 ); }
function mobius( z, a, b, c, d ) { return div_complex( add( mul_complex( a, z ), b ), add( mul_complex( c, z ), d ) ); }
function complex_conjugate( p ) { return p2( p.x, -p.y ); }

function mobius_normalize( cp ) {
    // VCA, p.150
    var sqrt_ad_minus_bc = sqrt_complex( sub( mul_complex( cp[0], cp[3] ), mul_complex( cp[1], cp[2] ) ) );
    for( var i = 0; i < 4; i++ )
        cp[i] = div_complex( cp[i], sqrt_ad_minus_bc );
}

function mobius_make_unitary( cp ) {
    cp[2] = mul( complex_conjugate( cp[1] ), -1 );
    cp[3] = complex_conjugate( cp[0] );
}

function mobius_make_nonloxodromic( cp ) {
    cp[3].y = -cp[0].y;
}

function enforce_constraints() {
    // hacky approach for now: enforce the constraints over and over until the control points stop moving
    var cp = control_points.slice();
    do {
        if( normalize )
            mobius_normalize( cp );
        if( unitary )
            mobius_make_unitary( cp );
        if( nonloxodromic )
            mobius_make_nonloxodromic( cp );
        var d = 0;
        for( var i = 0; i < 4; i++ ) {
            d += dist2( cp[i], control_points[i] );
            control_points[i] = cp[i];
        }
    } while( d > 1E-8 ); 
}

function mobius_identity( cp ) {
    cp[0] = p2( 1, 0 ); 
    cp[1] = p2( 0, 0 ); 
    cp[2] = p2( 0, 0 ); 
    cp[3] = p2( 1, 0 ); 
}

function toScreen( p ) { return add( origin_screen, complex_conjugate( mul( p, scale ) ) ); }
function fromScreen( p ) { return mul( complex_conjugate( sub( p, origin_screen ) ), 1.0 / scale ); }

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onTouchMove( evt ) {
    if( point_is_being_dragged )
        evt.preventDefault();
    onMove( fixTouch( evt.changedTouches[0] ) );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        control_points[ i_point ] = fromScreen( add( pos, drag_offset ) );
        enforce_constraints();
        draw();
    }
    else {
        // find the closest point, if within a minimum radius
        var iClosest = -1;
        var closest_dist2 = touch_radius * touch_radius;
        var num_control_points = 4;
        if( unitary ) num_control_points = 2; // only allow a and b to be dragged
        for( var i = 0; i < num_control_points; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                closest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            draw();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            draw();
        }    
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    onDown( fixTouch( evt.changedTouches[0] ) );
}

function onDown( pos ) {    
    // find the closest point, if within a minimum radius
    var iClosest = -1;
    var closest_dist2 = touch_radius * touch_radius;
    var num_control_points = 4;
    if( unitary ) num_control_points = 2; // only allow a and b to be dragged
    for( var i = 0; i < num_control_points; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            closest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        drag_offset = sub( toScreen( control_points[ i_point ] ), pos );
        draw();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        draw();
    }    
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        draw();
    }    
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        draw();
    }
}

// thanks to: http://stackoverflow.com/a/12714084/126823
function fixTouch (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
        // iOS4 clientX/clientY have the value that should have been
        // in pageX/pageY. While pageX/page/ have the value 0
        x = x - winPageX;
        y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX) ) {
        // Some Android browsers have totally bogus values for clientX/Y
        // when scrolling/zooming a page. Detectable since clientX/clientY
        // should never be smaller than pageX/pageY minus page scroll
        x = touch.pageX - winPageX;
        y = touch.pageY - winPageY;
    }
    var rect = canvas.getBoundingClientRect();
    return { x: x - rect.left, y:y - rect.top };
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    canvas.addEventListener( 'touchend',  onMouseUp, false );
    canvas.addEventListener( 'touchcancel',  onMouseUp, false );
    
    control_points = [ p2( 1.0, 0.0 ), p2( 0.2, 0.1 ), p2( 0.3, 0.4 ), p2( 1.1, -0.1 ) ];
    
    origin_screen = p2( canvas.width/2, canvas.height/2 );
    scale = Math.min( canvas.width, canvas.height ) / 5;
    
    point_is_highlighted = false;
    point_is_being_dragged = false;
    i_point = -1;
    grab_offset = p2( 0, 0 );
    
    touch_radius = 50;
    
    draw_grid = true;
    draw_arrows = false;
    normalize = false;
    draw_fixed_points = false;
    unitary = false;
    nonloxodromic = false;
    show_ad_minus_bc = false;
    show_a_plus_d = false;

    draw();
}

function drawPoint( p, r, t, t_offset ) { 
    ctx.beginPath(); 
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI ); 
    ctx.fillText( t, p.x + 5 + t_offset.x, p.y - 5 + t_offset.y );
    ctx.fill(); 
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

// adapted from http://stackoverflow.com/a/6333775/126823
function drawArrow( from, to ) { 
    var headlen = 5; // length of head in pixels
    var angle = Math.atan2(to.y-from.y,to.x-from.x);
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.moveTo(to.x-headlen*Math.cos(angle-Math.PI/6),to.y-headlen*Math.sin(angle-Math.PI/6));
    ctx.lineTo(to.x, to.y);
    ctx.lineTo(to.x-headlen*Math.cos(angle+Math.PI/6),to.y-headlen*Math.sin(angle+Math.PI/6));
}

function distanceOfPointFromLine( end1, end2, p ) {
    return Math.abs( (end2.y-end1.y)*p.x - (end2.x-end1.x)*p.y + end2.x*end1.y - end2.y*end1.x ) / dist( end1, end2 );
}

function drawSmoothTransformedLine( a, c ) {
    var b = average(a,c);
    var wa = fromScreen( a );
    var wb = fromScreen( b );
    var wc = fromScreen( c );
    var qa = mobius( wa, control_points[0], control_points[1], control_points[2], control_points[3] );
    var qb = mobius( wb, control_points[0], control_points[1], control_points[2], control_points[3] );
    var qc = mobius( wc, control_points[0], control_points[1], control_points[2], control_points[3] );
    var sa = toScreen( qa );
    var sb = toScreen( qb );
    var sc = toScreen( qc );
    // if nearly collinear then just draw straight lines
    var close_enough = 3;
    if( distanceOfPointFromLine( sa, sc, sb ) < close_enough ) {
        ctx.moveTo( sa.x, sa.y );
        ctx.lineTo( sb.x, sb.y );
        ctx.lineTo( sc.x, sc.y );
        return;
    }
    // otherwise recurse down
    drawSmoothTransformedLine( a, b );
    drawSmoothTransformedLine( b, c );
}

function drawSmoothTransformedArrow( sp ) {
    // interpolate between the identity transform and the current transform
    ctx.moveTo( sp.x, sp.y );
    var p = fromScreen( sp );
    var num_steps = 30;
    var cp = [];
    var target_p = control_points.slice();
    mobius_normalize( target_p );
    for( var i = 0; i < num_steps; i++ ) {
        var u = i / num_steps;
        mobius_identity( cp );
        for( var j = 0; j < 4; j++ )
            cp[ j ] = add( mul( target_p[ j ], u ), mul( cp[ j ], 1 - u ) );
        var q = mobius( p, cp[0], cp[1], cp[2], cp[3] );
        sq = toScreen( q );
        ctx.lineTo( sq.x, sq.y );
    }
    // draw the arrow using the last line segment
    var q = mobius( p, control_points[0], control_points[1], control_points[2], control_points[3] );
    var sq2 = toScreen( q );
    drawArrow( sq, sq2 );
}

function roundTowardsZero( x ) {
    return ( x > 0 ) ? Math.floor(x) : Math.ceil(x);
}

function draw() {

    // clear the area
    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.lineWidth = 1;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // draw the axes
    var lines = [ p2( -100, 0 ), p2( 100, 0 ), p2( 0, -100 ), p2( 0, 100 ) ];
    var min_x = roundTowardsZero( fromScreen( p2( 0, 0 ) ).x );
    var max_x = roundTowardsZero( fromScreen( p2( canvas.width, 0 ) ).x );
    var min_y = roundTowardsZero( fromScreen( p2( 0, canvas.height ) ).y );
    var max_y = roundTowardsZero( fromScreen( p2( 0, 0 ) ).y );
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    for( var i = 0; i < 2; i++ ) {
        var sp1 = toScreen( lines[ i*2 + 0 ] );
        var sp2 = toScreen( lines[ i*2 + 1 ] );
        ctx.moveTo( sp1.x, sp1.y );
        ctx.lineTo( sp2.x, sp2.y );
    }
    for( var x = min_x; x <= max_x; x++ ) {
        var sp1 = toScreen( p2( x, -0.05 ) );
        var sp2 = toScreen( p2( x, 0.05 ) );
        ctx.moveTo( sp1.x, sp1.y );
        ctx.lineTo( sp2.x, sp2.y );
    }
    for( var y = min_y; y <= max_y; y++ ) {
        var sp1 = toScreen( p2( -0.05, y ) );
        var sp2 = toScreen( p2( 0.05, y ) );
        ctx.moveTo( sp1.x, sp1.y );
        ctx.lineTo( sp2.x, sp2.y );
    }
    ctx.stroke();
    
    // draw arrows showing the transform
    if( draw_arrows ) {
        ctx.strokeStyle = "rgba(0,0,128,0.4)";
        var spacing = 40;
        ctx.beginPath();
        for( var x = canvas_rect.x + spacing / 2; x < canvas_rect.x + canvas_rect.width; x += spacing ) {
            for( var y = canvas_rect.y + spacing / 2; y < canvas_rect.y + canvas_rect.height; y += spacing ) {
                sp = p2( x, y );
                drawSmoothTransformedArrow( sp );
            }
        }
        ctx.stroke();
    }
    
    // draw a distorted grid to show the transform
    if( draw_grid ) {
        ctx.strokeStyle = "rgba(0,0,0,0.4)";
        var spacing = 40;
        ctx.beginPath();
        for( var x = canvas_rect.x; x < canvas_rect.x + canvas_rect.width; x += spacing ) {
            for( var y = canvas_rect.y; y < canvas_rect.y + canvas_rect.height; y += spacing ) {
                drawSmoothTransformedLine( p2( x, y ), p2( x + spacing, y ) );
                drawSmoothTransformedLine( p2( x, y ), p2( x, y + spacing ) );
            }
        }
        ctx.stroke();
    }
    
    // draw the four control points
    ctx.font="22px Arial";
    var rest_color = "rgb(0,0,0)";
    var highlighted_color = "rgb(0,255,255)";
    var dragging_color = "rgb(0,255,0)";
    var num_moveable_control_points = 4;
    if( unitary ) num_moveable_control_points = 2;
    for( var i = 0; i < 4; i++ ) {
        if( point_is_highlighted && i_point == i )
            ctx.fillStyle = ctx.strokeStyle = highlighted_color;
        else if( point_is_being_dragged && i_point == i )
            ctx.fillStyle = ctx.strokeStyle = dragging_color;
        else
            ctx.fillStyle = ctx.strokeStyle = rest_color;
        var radius = ( i < num_moveable_control_points ) ? 4 : 2;
        drawPoint( toScreen( control_points[ i ] ), radius, "abcd"[i], p2(0,0) );
    }
    
    if( draw_fixed_points ) {
        ctx.fillStyle = ctx.strokeStyle = "rgb(0,0,0)";
        var cp = control_points.slice();
        mobius_normalize( cp );
        var f1 = div_complex( add( sub(cp[0],cp[3]), sqrt_complex( sub( mul_complex( add(cp[0],cp[3]), add(cp[0],cp[3]) ), p2(4,0) ) ) ), mul( cp[2], 2.0 ) );
        var f2 = div_complex( sub( sub(cp[0],cp[3]), sqrt_complex( sub( mul_complex( add(cp[0],cp[3]), add(cp[0],cp[3]) ), p2(4,0) ) ) ), mul( cp[2], 2.0 ) );
        drawPoint( toScreen( f1 ), 2, "f1", p2(0,0) );
        drawPoint( toScreen( f2 ), 2, "f2", p2(0,0) );
    }
    
    if( show_a_plus_d ) {
    
        if( normalize ) {
            // show the classification region
            ctx.fillStyle = ctx.strokeStyle = "rgba(0,160,0,0.2)";
            ctx.lineWidth = 5;
            var sp1 = toScreen( p2( -2, 0 ) );
            var sp2 = toScreen( p2( 2, 0 ) );
            ctx.beginPath();
            ctx.moveTo( sp1.x, sp1.y );
            ctx.lineTo( sp2.x, sp2.y );
            ctx.stroke();
            drawPoint( toScreen( p2( -2, 0 ) ), 5, "", p2(0,0) );
            drawPoint( toScreen( p2( 2, 0 ) ), 5, "", p2(0,0) );
        }

        var a_plus_d = add( control_points[0], control_points[3] );
        ctx.fillStyle = ctx.strokeStyle = "rgb(0,0,0)";
        drawPoint( toScreen( a_plus_d ), 2, "a+d", p2(0,0) );
    }

    if( show_ad_minus_bc ) {
        var ad_minus_bc = sub( mul_complex( control_points[0], control_points[3] ), mul_complex( control_points[1], control_points[2] ) );
        ctx.fillStyle = ctx.strokeStyle = "rgb(0,0,0)";
        drawPoint( toScreen( ad_minus_bc ), 2, "ad-bc", p2(0,0) );
    }
}

function onGridButton(element) { 
    draw_grid = !draw_grid; 
    element.value = draw_grid ? "Grid: ON" : "Grid: OFF";
    draw(); 
}

function onArrowsButton(element) {
    draw_arrows = !draw_arrows; 
    element.value = draw_arrows ? "Arrows: ON" : "Arrows: OFF";
    draw(); 
1}

function onNormalizeButton(element) {
    normalize = !normalize; 
    element.value = normalize ? "Normalize: ON" : "Normalize: OFF";
    enforce_constraints();
    draw(); 
}

function onFixedPointsButton(element) {
    draw_fixed_points = !draw_fixed_points; 
    element.value = draw_fixed_points ? "Fixed points: ON" : "Fixed points: OFF";
    draw(); 
}

function onShowAPlusDButton(element) {
    show_a_plus_d = !show_a_plus_d; 
    element.value = show_a_plus_d ? "Show a+d: ON" : "Show a+d: OFF";
    draw(); 
}

function onShowADMinusBCButton(element) {
    show_ad_minus_bc = !show_ad_minus_bc; 
    element.value = show_ad_minus_bc ? "Show ad-bc: ON" : "Show ad-bc: OFF";
    draw(); 
}

function onUnitaryButton(element) {
    unitary = !unitary;
    element.value = unitary ? "Unitary: ON" : "Unitary: OFF";
    enforce_constraints();
    draw(); 
}

function onNonLoxodromicButton(element) {
    nonloxodromic = !nonloxodromic; 
    element.value = nonloxodromic ? "Non-loxodromic: ON" : "Non-loxodromic: OFF";
    enforce_constraints();
    draw(); 
}

function onIdentityButton() {
    mobius_identity( control_points );
    enforce_constraints();
    draw(); 
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input[type='button'] { 
    font-size: 20px; 
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
}
</style>

</head>

<body>

<p>The <b><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">Möbius transformation</a></b> is <b>f( z ) = ( az + b ) / ( cz + d )</b> where <b>z</b>, <b>a</b>,
<b>b</b>, <b>c</b> and <b>d</b> are complex numbers. Drag the points to change the transformation.</p>

<div style="float:left"><p><canvas id="canvas" width="700" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

<div style="float:left;padding-left: 20px">

<p><input type="button" value="Arrows: OFF" onclick="onArrowsButton(this)" /></p>
<p><input type="button" value="Grid: ON" onclick="onGridButton(this)" /></p>
<p><input type="button" value="Identity" onclick="onIdentityButton()" /></p>
<p><input type="button" value="Normalize: OFF" onclick="onNormalizeButton(this)" /></p>
<p><input type="button" value="Show ad-bc: OFF" onclick="onShowADMinusBCButton(this)" /></p>
<p><input type="button" value="Fixed points: OFF" onclick="onFixedPointsButton(this)" /></p>
<p><input type="button" value="Unitary: OFF" onclick="onUnitaryButton(this)" /></p>
<p><input type="button" value="Non-loxodromic: OFF" onclick="onNonLoxodromicButton(this)" /></p>
<p><input type="button" value="Show a+d: OFF" onclick="onShowAPlusDButton(this)" /></p>

</div>

<div style="clear:both">
<p>To simplify the transformation, set <b>c</b> to zero (move it to the origin). Now <b>a</b> and <b>b</b> between 
them give a similarity transformation: <b>a</b> controls the scale and rotation while <b>b</b> controls the translation.</p>

<p>The identity transformation is given when <b>b</b>=<b>c</b>=0 and <b>a</b>=<b>d</b>.</p>

<p>A <i>normalized</i> Möbius transformation is one where <b>ad - bc = 1</b>.</p>

<p>A <i>unitary</i> Möbius transformation has <b>c = -b&#773;</b> and <b>d = a&#773;</b> (where <b>z&#773;</b> is the <a href="https://en.wikipedia.org/wiki/Complex_conjugate">complex conjugate</a> of <b>z</b>).</p>

<p>A normalized Möbius transformation is <i>loxodromic</i> if <b>a+d</b> is not on the real line. Set <b><tt>Non-loxodromic:ON</tt></b> to enforce that <b>a+d</b> is real, and <b><tt>Normalize:ON</tt></b> to ensure that the transformation is normalized. Then if <b>|a+d| < 2</b> the Möbius transformation is <i>elliptic</i>. If <b>|a+b|=2</b> then it is <i>parabolic</i>. Otherwise, with <b>|a+d| > 2</b>, it is <i>hyperbolic</i>.

<p>If the unit circle is the Poincare disk model of the hyperbolic plane, then the Möbius transformation with <b>c = b&#773;</b> and <b>a = d = 1</b> is an isometry of the hyperbolic plane corresponding to a translation of the origin by <b>b</b>.</p>

<p>Read the book <a href="http://www.amazon.co.uk/Visual-Complex-Analysis-Tristan-Needham/dp/0198534469">Visual Complex Analysis</a> by Tristan Needham. To see the relationship with the Riemann sphere, see <a href="https://www.youtube.com/watch?v=0z1fIsUNhO4">this amazing video</a>.</p>

<hr>

<p>Source code: <a href="https://github.com/timhutton/mobius-transforms">https://github.com/timhutton/mobius-transforms</a></p>

</div>
</html>
